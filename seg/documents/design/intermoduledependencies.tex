\newcolumntype{C}[1]{>{\Centering}p{#1}}
\def\TabS#1#2{\small\tabular{#1}\rule[-1.5mm]{0pt}{5mm}{#2}
    \rule[-2mm]{0pt}{2mm}\endtabular}
\def\TabA#1#2#3{\small\tabular{#1}\rule[-1.5mm]{0pt}{5mm}\textbf{#2}\\
    \hline\rule[0mm]{0pt}{4mm}#3
    \rule[-2mm]{0pt}{2mm}\endtabular}
\def\TabB#1#2#3{\small\tabular{c}\rule[-1.5mm]{0pt}{5mm}
    \textbf{{\tiny$\ll$}#1{\tiny$\gg$}}\\
    \hline\rule[0mm]{0pt}{4mm}\tabular{ll}#2\endtabular \\
    \hline\rule[0mm]{0pt}{4mm}\tabular{ll}#3\endtabular
    \rule[-2mm]{0pt}{2mm}\endtabular}
\seticonparams{entity}{
    shadow=false,
    fillcolor=blue!10,
    fillstyle=solid,
    framesep=0pt}

\subsection{Intermodule Dependencies}
\subsubsection{Top Level Structures}
It was apparent from the briefing and requirements that the application would be most suited to a data-centred repository system with the data stored on a distinct central remote server that would be accessed as and when required by the applications running on the separate android phones. The particular aspect of the same data being available to all instances of the android application simultaneously was the main reason the centred data model being chosen. Due to the nature of caches no data can be considered unique to a single user, instead with all users having needs to access the same data. To handle this centralised data a bespoke webserver was created to handle access to a MySQL database to store all data necessary for the android application to run. 

\begin{figure}[h!]
    \centering
    \begin{tabular}{c}
    \entity{server}[\TabA{c}{Centralized Server}{~\\[-3mm]
        \tabular{c}~\\[-10mm]
            \entity{database}[\TabS{c}{Database Module}]\\[8mm]
            \entity{serverlogic}[\TabS{c}{Logic Module}]\\[-3mm]
        \endtabular
        \hspace{5mm}
        \entity{web}[\TabA{c}{Web Interface}{~\\[-3mm]
            \entity{api}[\TabS{c}{API Module}]\\[2mm]
            \entity{website}[\TabS{c}{Website Module}]\\[-3mm] 
        }]\\[-3mm]
    }]
    \hspace{5mm}
    \entity{app}[\TabA{c}{Android Application}{~\\[3mm]
        \hspace{-5mm}
        \tabular{cc}
        \tabular{c}~\\[-10mm]
            \entity{request}[\TabS{c}{Request Module}]\\[8mm]
            \entity{applogic}[\TabS{c}{Logic Module}]\\[-3mm]
        \endtabular
        \hspace{2mm}
        \tabular{c}~\\[-10mm]
            \entity{window}[\TabS{c}{Window Module}]\\[8mm]
            \entity{geo}[\TabS{c}{Geolocation Module}]\\[-3mm]
        \endtabular\hspace{-3mm}
        \endtabular
        \\[3mm]
    }]
    \end{tabular}
    {\small
        \ncline[arrowscale=1.5]{<->}{database}{serverlogic}
        \ncline[arrowscale=1.5]{<->}{web}{serverlogic}
        \ncline[arrowscale=1.5]{->}{database}{web}
        \ncline[arrowscale=1.5]{<->}{api}{request}
        \ncline[arrowscale=1.5]{<->}{request}{applogic}
        \ncline[arrowscale=1.5]{<->}{window}{applogic}
        \ncline[arrowscale=1.5]{->}{request}{window}
        \ncline[arrowscale=1.5]{->}{geo}{applogic}
    }
    \caption{Data flow of the top level of the system, showing the application and server separated by the dashed line, with a clearly visible breakdown of the application into the Model, Controller and View.}
\end{figure}

Due to the requirements of also having a website with much of the functionality that is also required within the application, the decision have a database and separate server was deemed necessary. By having this split structure, both the website and application can have a common interaction point for the data centred model, to help reduce data access concurrency problems as well as having common methods for the same data access regardless of whether the application or website is making access request for data within the database.

\begin{figure}[h!]
    \centering
    \begin{tabular}{rcl}
    ~ &
    \entity{database}[\TabS{C{3cm}}{Database}] & ~
    \\[1cm]
    \entity{application}[\TabS{C{3cm}}{Application}]
    \hspace{1cm}
    \pnode(0,2){arrowtop}
    \pnode(0,-0.5){arrowbottom}
    \hspace{1cm} &
    \entity{server}[\TabS{C{3cm}}{Server}] &
    \hspace{1cm}
    \entity{website}[\TabS{C{3cm}}{Website}] \\ ~
    \end{tabular}
    {\small
        \ncline[arrowscale=1.5]{<->}{database}{server}
        \ncline[arrowscale=1.5,linestyle=dashed]{<->}{arrowtop}{arrowbottom}
        \ncline[arrowscale=1.5]{<->}{server}{application}
        \ncline[arrowscale=1.5]{<->}{server}{website}
    }
    \caption{Top level dataflow for the overall system including a centralised database and server and the application and website which interact with server separately.}
\end{figure}

\newpage
\subsubsection{Model Decomposition}
Due the centralised nature of the data, the Models main function is to make basic get and set requests of the server and parse those results through the use of a json parser ready for the results to be sent to the controller and view of the GUI. This method means that no data is truly stored within the Model of the application, and instead it is only used to control the data flow and interpretation. The Model contains five classes: ServerRequests, CurrentUser, User, Login and Cache. The ServerRequests class contains the majority of the get and set methods required by the application. Each class can then call one of these classes to either retrieve data or send data to the server to be used without needed to interpret the data that the server itself uses.

\begin{figure}[h!]
    \centering
    \begin{tabular}{rcl}
    \entity{currentuser}[\TabB{CurrentUser}{
        (static) me &: CurrentUser \\
        sessionID &: String \\
        phash &: String \\
        balance &: String \\
        numberOfCaches &: String \\
        totalBalance &: String
    }{
        setSessionID(x : String) &: void \\
        setBalance(x : String) &: void \\
        setNumberOfCaches(x : String) &: void \\
        setTotalBalance(x : String) &: void \\
        get
    }]
    \end{tabular}
    \caption{Showing the properties and methods of classes within the Model component.}
\end{figure}

\subsubsection{Graphical User Interface Decomposition}
The graphical user interface is the largest and most complex component of the application, facilitating user interaction with the application as well as displaying all the possible actions the user can take and results of those actions. The java class Window is the primary class within the GUI with most other GUI related classes inheriting from the Window class.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{imdfig4}
    \caption{Properties, classes, methods and Inheritance of the GUI component of the Application.}
\end{figure}


\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\textwidth]{imdfig5}
\end{figure}
