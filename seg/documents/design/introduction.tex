\section{Introduction}

\subsection{Purpose}

The purpose of this document is to provide a thorough guide for developers to implement the virtual geocaching application Fortitude. It expands on the higher level descriptions provided in the requirements document, through the use of clear diagrams and high and low level designs, so it can be used to create software that fulfills the specification laid out therein. 

From this document a mobile application and supporting website will be produced that encapsulate an exciting game based on creating, defending and conquering caches. The system realised will allow users to create accounts that can be used for playing the game Fortitude, and will be able to interact with this game through an easy to use and appealing interface.

\subsection{Scope}

The design of the system covers user creating accounts to be used with the game, in which an army is utilized to conquer and defend caches (playing the role of forts). The aim of the game of the game is to own the most caches. The user’s army size will grow relative to the number of caches owned, with the size of the garrison defending the cache influencing how often new soldiers are produced. Army size can also be increased by attacking outlaw camps which will not change ownership, only provide soldiers when defeated. Users gain caches by placing new ones and using their army to conquer other user’s caches. They must leave soldiers at caches to defend against attacks. Game play happens through the application; the website allows users to manage accounts and plan strategies. In future releases, the website will include a forum or message board to further user interaction which allows for more complex strategies and alliances. In the current version, users can communicate via a private messaging system on the app and website. Administrators use the website to place or delete caches remotely, delete user accounts and act on user requests including questions or reporting a cache, a particular user communication or another user.

Accounts are created with a username, password and email address through the phone application or website, and are validated through an activation email sent to the user. Users can request a password reset email and, if their account is not activated, a new activation email. Once authenticated, the user builds up their army of soldiers and interact with caches at their location. Caches, the user’s location are displayed on a map as well as a route to a cache if requested. Interactions with caches include placing one if 300m away from any other cache; adding or withdrawing soldiers from a cache the user owns to change the size of the defensive army guarding it; adding soldiers to an empty, unowned cache in order to become the owner; or scouting and/ or attacking an enemy cache. At any time, users can see basic information about caches, such as who owns it, and can the profile of that user, which provides information such as the number of caches they own.

User’s scout a cache to find out the size of its defensive army without attacking it. Scouting is done by sending a number of soldiers to the cache(each of which can fail and die, which reduces the user’s army). A user can attack a cache after or without scouting, and specifies the number of soldiers to attack with. If they are victorious they become the new owner of that fort, the surviving soldiers of their attacking army become the new defending army of the cache, and a proportion of soldiers originally defending the cache surrender and join the attacking army. If the attackers lose, every attacking soldier is lost, the surviving defenders will continue defending the cache, a proportion of the lost soldiers will surrender and join the army of the owner of the cache. After the battle, the user will be displayed a breakdown of results including the initial number of soldiers in each army, the winner of the battle, the survivors of the attacking side and the amount of soldiers that surrendered to the winning side. The user whose cache had been attacked will receive a similar report through a notification system in the app, which will also alert users to messages received from other users.

Outlaw camps are non-player caches which can never be conquered, but are attacked like user owned caches. The camps are defended by a number of soldiers proportional to the total number of soldiers the attacking user owns, including defenders of the user’s caches. Successfully defeating an outlaw camp, will give the user more soldiers than they lost in the attack, but if they lose then all the soldiers will be lost. After defeating an outlaw camp that user cannot attack the camp again for an amount of time that is proportional to the number of soldiers defending it.

Special event caches (or treasure areas) are very different from other caches as they are not visible on the map. When a user enters the range of a wireless access point with a MAC address specified by admins, the cache is found. Minimum distance rules do not apply to these caches because they are specified by MAC address and not GPS location. The caches reward users finding them with soldiers, however in future releases the treasure might include weapons or advanced soldiers that would strengthen the user’s army. Each special event cache will only reward a user once and has a limited supply of treasure, so only a certain number of users can find it unless refilled by an administrator.

On the website, users can view caches on a map using a filter for example to search only for enemy caches. They can view information about their own caches and account including a record of their game history. A user can manage their account through the website, including updating their details, changing their password or requesting their account be deleted.

The application and website use a database storing each cache and user which is accessed and updated by a server. This server provides the functionality for the website and app, and checks the validity of data and commands to reduce errors. It also reduces cheating by ensuring location specific actions are performed at the correct location. Certain restricted features, such as promoting a user to an administrator, can only be accessed directly through the server.

\subsection{Definitions, Acronyms and Abbreviations}
\def\Definition#1#2{\noindent{\bf #1}: #2}

\Definition{GUI}{Graphical User Interface. A GUI is a visual way of interacting with a computer via windows, icons, and menus.}

\Definition{View}{A view is a superclass of all GUI element in the Android screen display environment}

\Definition{MAC Address}{Media access control address. A MAC address acts as a unique identifier assigned to a network interface for communications on the physical network.}

\Definition{GPS}{Global Positioning System. GPS is a space-based satellite navigation system that provides location , anywhere on Earth where line of sight is available to a minimum of four GPS satellites.}

\Definition{Database}{A database is a collection of data organised to model relevant aspects of reality while allowing process requiring this information to access it.}

\Definition{Server}{A server is a physical computer that is dedicated to run one or more services as a host. The client-server architecture implies the server is running to server the requests of other programs.}

\Definition{Splash Screen}{A splash screen covers the entire screen and displays an image so the user has something to view while a program loads.}

\Definition{HTTP}{Hypertext Transfer Protocol. HTTP is the foundation of data transfer for the World Wide Web, it is an application protocol for distributed, collaborative, hypermedia information systems.}

\Definition{API}{Application Programming Interface. An API protocol is intended to be used as an interface by software components to allow inter-component communication. An API library may contain specifications for routines, data structures, object classes, and variables.}

\Definition{DBMS}{Database management system. A DBMS program is a program that enables storing, modifying, and extracting information from a database.}

\Definition{.NET}{The .NET Framework is a software framework developed by Microsoft which includes a large library and provides language interoperability across several programming languages.}

\Definition{CLR}{Common Language Runtime. The CLR is the virtual machine component of Microsoft's .NET framework and is responsible for managing the execution of .NET programs.}

\Definition{SQL}{Structured Query Language. SQL is a programming language designed for managing data held in a relational database management system.}

\Definition{SQLite}{A relational database management system.}

\Definition{IDE}{Integrated development environment. An IDE provides facilities for software development via a software application.}

\Definition{SqlCe}{SQL Server Compact. SQL CE is a compact relational database for applications that run on mobile devices and desktops.}

\Definition{DDL}{Data definition language. A DDL is similar to a computer programming language for defining data structures.}

\Definition{LINQ}{Language Integrated Query. LINQ is a .NET Framework component that adds .NET data querying capabilities.}

\Definition{JSON}{JavaScript Object Notation is derived from the JavaScript scripting language designed for human-readable data interchange.}

\Definition{HTML}{HyperText Markup Language. HTML is the main markup language for creating web pages and other web browser based content.}

\Definition{PHP}{PHP is a server-side scripting language designed for Web development, to allow for production of dynamic Web 
pages.}

\Definition{CGI}{Common Gateway Interface. The CGI is a standard for executable files known as CGI scripts to generate web content when delegated by web servers.}

\Definition{AJAX}{Asynchronous JavaScript and XML. AJAX is a group of interrelated web development techniques used on the client-side to create asynchronous web applications.}

\subsection{References}

23 Cats, 2012. \emph{Requirements Document 2012-13, Project Name: Geocaching}, Unpublished

Bell, D., 2005. \emph{Software Engineering For Students: A Programming Approach}, 4th edition, London: Pearson Education Limited

Dix, A., Finaly, J., Abowd, G., Beale, R., 1993. \emph{Human-Computer Interaction}, Cambridge: Prentice Hall International (UK) Limited

Sommerville, I., 2004. \emph{Software Engineering}, 7th edition, New York: Addison-Wesley Publishers Limited

\subsection{Overview}

The remainder of this document will be a thorough guide for developers of this system. It will be split into Interface Descriptions and Element Descriptions. In the Interface Description section there will be mock ups of the user interface for both the app and website and descriptions and diagrams of how a user might use these. The Element Description section will design the system architecture and core parts of the system, and explain decisions along the way. It will do this through design elements each with a specific function, shown through block diagrams. Class diagrams will be used to show the static structure of the system and dependencies between components. Activity diagrams and sequence diagrams will be used to show the dynamic behaviour of the system.



